// Prisma Schema for AKARI Mystic Club
// Telegram Mini App - Prediction Marketplace with MYST Token Economy

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MODEL
// ============================================
model User {
  id         String   @id @default(cuid())
  telegramId String   @unique
  username   String?
  firstName  String?
  lastName   String?
  photoUrl   String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Legacy points (aXP - experience points, non-monetary)
  points           Int     @default(0)
  tier             String? // e.g. "Seeker", "Mystic", "Oracle"
  credibilityScore Float   @default(0)
  positiveReviews  Int     @default(0)
  negativeReviews  Int     @default(0)

  // Referral system
  referrerId   String? // User ID who referred this user
  referrer     User?   @relation("Referrals", fields: [referrerId], references: [id])
  referrals    User[]  @relation("Referrals")
  referralCode String? @unique // Unique code for sharing

  // TON wallet (for withdrawals)
  tonAddress  String? // TON wallet address
  tonLinkedAt DateTime? // When the wallet was linked

  // Relations
  twitterAccounts    TwitterAccount[]
  bets               Bet[]
  campaignsProgress  CampaignUserProgress[]
  mystTransactions   MystTransaction[]
  referralEvents     ReferralEvent[] // Events where this user spent MYST
  referralRewards    ReferralEvent[]        @relation("ReferralRewards") // Rewards received
  leaderboardRewards LeaderboardReward[]
  campaignRequests   CampaignRequest[]
  predictionRequests PredictionRequest[]
  wheelSpins         WheelSpin[]
  withdrawalRequests WithdrawalRequest[]
  deposits           Deposit[]

  // Campaign relations
  campaignReferralsGiven    CampaignReferral[] @relation("CampaignReferrer")
  campaignReferralsReceived CampaignReferral[] @relation("CampaignReferred")
  campaignWins              CampaignWinner[]

  // Reviews (credibility system)
  reviewsGiven    Review[] @relation("ReviewerReviews")
  reviewsReceived Review[] @relation("RevieweeReviews")

  // Onboarding flags
  hasSeenBotWelcome      Boolean @default(false)
  hasSeenOnboardingGuide Boolean @default(false)

  // Broadcast preferences
  allowAnnouncements Boolean @default(true)
}

model TwitterAccount {
  id             String    @id @default(cuid())
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  twitterUserId  String    @unique
  handle         String?
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}

// ============================================
// MYST TOKEN ECONOMY
// ============================================

// MYST Transaction Ledger - all MYST movements are recorded here
// Balance = SUM(amount) for a user
model MystTransaction {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  // Transaction type
  type String // "stars_conversion", "bet", "win", "referral_reward", "burn_for_reward", "admin_grant", "campaign_fee", "boost"

  // Amount: positive = credit, negative = debit
  amount Float

  // Optional metadata (predictionId, weekId, referralEventId, etc.)
  meta Json?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([userId, type])
  @@index([userId, createdAt])
}

// Referral Events - tracks when users spend MYST and referrers earn rewards
model ReferralEvent {
  id String @id @default(cuid())

  // The user who spent MYST
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  // Level 1 referrer (direct)
  referrerLevel1   User?   @relation("ReferralRewards", fields: [referrerLevel1Id], references: [id])
  referrerLevel1Id String?
  rewardLevel1     Float   @default(0) // MYST rewarded to level 1

  // Level 2 referrer (indirect)
  referrerLevel2Id String?
  rewardLevel2     Float   @default(0) // MYST rewarded to level 2

  // The MYST spent that triggered this event
  mystSpent Float
  spendType String // "bet", "campaign_fee", "boost"

  // Reference to what was purchased (optional)
  referenceId String? // predictionId, campaignId, etc.

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([referrerLevel1Id])
  @@index([createdAt])
}

// ============================================
// WEEKLY LEADERBOARD REWARDS
// ============================================
model LeaderboardReward {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  // Week identifier (e.g., "2025-W48" or "2025-11-25_2025-12-01")
  weekId String

  // Category: "top_spender", "top_referrer", "top_campaign"
  category String

  // Rank in that category for that week
  rank Int

  // Reward amount in USD (set by admin, hidden from user until paid)
  rewardUsd Float

  // MYST burn requirement (computed: rewardUsd / 2 * 1.1)
  requiredMyst Float

  // Actual MYST burned by user
  burnedMyst Float @default(0)

  // User's TON wallet at claim time
  tonWallet String?

  // Status flow: pending_burn -> ready_for_payout -> paid
  status String @default("pending_burn") // "pending_burn", "ready_for_payout", "paid"

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  paidAt    DateTime?

  @@unique([userId, weekId, category])
  @@index([weekId])
  @@index([status])
}

// ============================================
// PREDICTIONS & BETTING
// ============================================
model Prediction {
  id          String   @id @default(cuid())
  title       String
  description String?
  category    String? // e.g., "CRYPTO", "POLITICS", "SPORTS", "ENTERTAINMENT"
  options     String[] // e.g. ["Yes","No"]

  // Status: DRAFT, ACTIVE, PAUSED, RESOLVED, CANCELLED
  status String @default("ACTIVE")

  // Legacy fee structure (kept for backwards compatibility)
  entryFeeStars  Int @default(0)
  entryFeePoints Int @default(0)

  // MYST-based fee (new)
  entryFeeMyst Float @default(0)

  // Pool totals in MYST
  mystPoolYes Float @default(0)
  mystPoolNo  Float @default(0)

  // Platform fee rate (e.g., 0.08 = 8%)
  feeRate Float @default(0.08)

  // Legacy pot (kept for backwards compatibility)
  pot Int @default(0)

  resolved         Boolean   @default(false)
  winningOption    String?
  resolvedAt       DateTime?
  endsAt           DateTime?
  participantCount Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bets Bet[]

  @@index([status])
}

// Prediction Request from community
model PredictionRequest {
  id             String    @id @default(cuid())
  question       String // The prediction question
  category       String? // e.g., "CRYPTO", "POLITICS", "SPORTS"
  proposedExpiry DateTime?
  details        String? // Extra context
  status         String    @default("PENDING") // PENDING, APPROVED, REJECTED

  createdById String?
  createdBy   User?   @relation(fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

model Bet {
  id           String     @id @default(cuid())
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  prediction   Prediction @relation(fields: [predictionId], references: [id], onDelete: Cascade)
  predictionId String

  option String

  // Legacy betting (kept for backwards compatibility)
  starsBet  Int @default(0)
  pointsBet Int @default(0)

  // MYST betting (new)
  mystBet Float @default(0)

  // Payout received (filled on resolution)
  mystPayout Float?

  createdAt DateTime @default(now())

  @@unique([userId, predictionId]) // One bet per user per prediction
  @@index([predictionId])
  @@index([userId, createdAt])
}

// ============================================
// CAMPAIGNS
// ============================================
model Campaign {
  id          String    @id @default(cuid())
  name        String
  description String?
  rewards     String
  status      String    @default("DRAFT") // DRAFT, ACTIVE, PAUSED, ENDED
  startAt     DateTime?
  endsAt      DateTime

  // Fee structure
  starsFee Int   @default(0)
  mystFee  Float @default(0) // MYST fee for joining

  // Winner settings
  winnerCount     Int     @default(25) // 25, 50, or 100 winners
  referralBonus   Int     @default(5) // Bonus aXP per referral
  winnersSelected Boolean @default(false)
  selectionRuns   Int     @default(0) // Number of times winners have been selected

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tasks     CampaignTask[]
  progress  CampaignUserProgress[]
  referrals CampaignReferral[]
  winners   CampaignWinner[]

  @@index([status])
  @@index([endsAt])
}

// Track campaign-specific referrals
model CampaignReferral {
  id           String   @id @default(cuid())
  campaign     Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  campaignId   String
  referrer     User     @relation("CampaignReferrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId   String
  referred     User     @relation("CampaignReferred", fields: [referredId], references: [id], onDelete: Cascade)
  referredId   String
  bonusAwarded Boolean  @default(false)

  createdAt DateTime @default(now())

  @@unique([campaignId, referredId]) // Each user can only be referred once per campaign
  @@index([campaignId, referrerId])
}

// Campaign winners
model CampaignWinner {
  id             String   @id @default(cuid())
  campaign       Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  campaignId     String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  rank           Int // 1-100
  totalPoints    Int // Points earned in this campaign
  tasksCompleted Int // Number of tasks completed
  referralCount  Int      @default(0) // Number of friends referred
  selectionRun   Int      @default(1) // Which run (1, 2, 3, etc.)

  createdAt DateTime @default(now())

  @@unique([campaignId, userId, selectionRun])
  @@index([campaignId, rank])
  @@index([campaignId, selectionRun])
}

model CampaignTask {
  id         String   @id @default(cuid())
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  campaignId String

  title        String
  description  String?
  type         String // e.g. "X_LIKE", "X_FOLLOW", "JOIN_TELEGRAM", "QUOTE_REPOST", "CUSTOM"
  targetUrl    String? // URL for the task (e.g., tweet to like, account to follow)
  proofType    String? // "LINK", "SCREENSHOT", "TWEET_URL"
  rewardPoints Int     @default(0) // Points/aXP reward for completing task
  rewardMyst   Float   @default(0) // MYST reward for completing task
  metadata     Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  progress CampaignUserProgress[]
}

// Campaign Request from projects/community
model CampaignRequest {
  id              String    @id @default(cuid())
  projectName     String
  contactHandle   String // Primary contact (e.g., @handle)
  contactTelegram String? // Telegram username
  contactX        String? // X/Twitter handle
  goal            String? // What they want to achieve
  requestedStart  DateTime?
  requestedEnd    DateTime?
  details         String? // Long description
  status          String    @default("PENDING") // PENDING, APPROVED, REJECTED

  createdById String?
  createdBy   User?   @relation(fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

model CampaignUserProgress {
  id         String       @id @default(cuid())
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  campaign   Campaign     @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  campaignId String
  task       CampaignTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId     String

  completed   Boolean   @default(false)
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, taskId])
  @@index([campaignId, userId])
  @@index([userId, completed])
}

// ============================================
// WEEKLY CONFIGURATION (Admin-managed)
// ============================================
model WeeklyConfig {
  id     String @id @default(cuid())
  weekId String @unique // e.g., "2025-W48"

  // Week boundaries
  startTime DateTime // Tuesday 23:00 UTC
  endTime   DateTime // Monday 12:00 UTC

  // Reward window
  claimStartTime DateTime // Monday 12:00 UTC
  claimEndTime   DateTime // Tuesday 23:00 UTC

  // Budget allocations in USD
  budgetTopSpenders  Float @default(0)
  budgetTopReferrers Float @default(0)
  budgetTopCampaign  Float @default(0)

  // Number of winners per category
  winnersPerCategory Int @default(10)

  // Status
  snapshotTaken Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// WHEEL OF FORTUNE
// ============================================

// Wheel Pool - accumulates 5% of all MYST spent
model WheelPool {
  id        String   @id @default("main_pool")
  balance   Float    @default(0)
  updatedAt DateTime @updatedAt
}

// Individual wheel spins
model WheelSpin {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  prizeType String   @default("myst") // "myst" or "axp"
  mystWon   Float    @default(0)
  axpWon    Int      @default(0)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

// ============================================
// TON INTEGRATION (Model A Withdrawals)
// ============================================

// Withdrawal requests - manual payout by admin
model WithdrawalRequest {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  // TON address at time of request
  tonAddress String

  // MYST amounts
  mystRequested Float // Total MYST requested
  mystFee       Float // 2% fee retained
  mystBurn      Float // Amount burned (mystRequested - mystFee)

  // USD/TON conversion
  usdNet      Float // Net USD value after fee
  tonAmount   Float // TON to send
  tonPriceUsd Float // TON price at time of request

  // Status: pending -> paid | rejected
  status          String  @default("pending")
  txHash          String? // TON transaction hash when paid
  rejectionReason String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  paidAt    DateTime?

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// Deposits - TON received (populated by external watcher)
model Deposit {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  // TON intended/received
  tonAmount   Float
  tonPriceUsd Float // TON price at time of deposit
  usdAmount   Float // tonAmount * tonPriceUsd

  // MYST to be credited
  mystEstimate Float // usdAmount * MYST_PER_USD
  mystCredited Float @default(0) // Actual MYST credited (0 until confirmed)

  // Deposit memo for matching
  memo String // AKARI:<userId>

  // Status: pending -> confirmed | declined
  status String @default("pending")

  // Transaction details (filled when confirmed)
  txHash      String?   @unique
  confirmedAt DateTime?

  // Decline details (filled when declined)
  declinedReason String?
  declinedAt     DateTime?
  declinedBy     String? // Admin who declined

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([memo])
  @@index([createdAt])
}

// ============================================
// POOL BALANCES (System accounts)
// ============================================

// Tracks various pool balances
model PoolBalance {
  id        String   @id // "leaderboard", "referral", "wheel", "treasury"
  balance   Float    @default(0)
  updatedAt DateTime @updatedAt
}

// ============================================
// USER REVIEWS (Credibility System)
// ============================================

model Review {
  id         String   @id @default(cuid())
  reviewer   User     @relation("ReviewerReviews", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewerId String
  reviewee   User     @relation("RevieweeReviews", fields: [revieweeId], references: [id], onDelete: Cascade)
  revieweeId String
  score      Int // +1 (positive) or -1 (negative)
  comment    String   @db.VarChar(255)
  link       String?  @db.VarChar(255) // Optional supporting link
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([reviewerId, revieweeId]) // One review per reviewer→reviewee pair
  @@index([revieweeId])
}

// ============================================
// TELEGRAM GROUPS (For task verification)
// ============================================

model TgGroup {
  id         String   @id // chatId as string
  title      String
  username   String? // @groupname if public
  isActive   Boolean  @default(true)
  isAdmin    Boolean  @default(false) // Bot is admin in this group
  allowPromo Boolean  @default(true) // Allow promotional messages
  introSent  Boolean  @default(false) // Intro message sent
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([isActive])
  @@index([isAdmin])
}

// ============================================
// PORTAL MODELS (Web Portal - akarimystic.club)
// ============================================

enum LaunchPlatformKind {
  LAUNCHPAD
  CEX
  DEX
  OTHER
}

model PortalUserProfile {
  id              String   @id @default(cuid())
  telegramId      String   @unique
  username        String?
  avatarUrl       String?
  level           String   @default("L1") // "L1", "L2", "ADMIN", "SUPER_ADMIN"
  positiveReviews Int      @default(0)
  negativeReviews Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  launches         NewLaunch[]
  createdPlatforms LaunchPlatform[]
  createdInvestors LeadInvestor[]
}

model LaunchPlatform {
  id          String             @id @default(cuid())
  name        String
  slug        String             @unique
  description String?
  website     String?
  kind        LaunchPlatformKind @default(LAUNCHPAD)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  createdById String?
  createdBy   PortalUserProfile? @relation(fields: [createdById], references: [id])

  launchesAsPrimary NewLaunch[] @relation("PrimaryPlatformOnLaunch")
  launchesAsListing NewLaunch[] @relation("ListingPlatformOnLaunch")
  launches          NewLaunch[] // Legacy relation, kept for backward compatibility
}

model NewLaunch {
  id          String  @id @default(cuid())
  name        String
  tokenSymbol String
  tokenName   String?
  chain       String? // e.g. "ETH", "BSC", "SOL", "TON"
  category    String? // e.g. "LAUNCHPAD", "AIRDROP", "IDO", "IEO"
  status      String? // e.g. "UPCOMING", "SALE", "LISTED"

  // Legacy platform relation (kept for backward compatibility)
  platformId String?
  platform   LaunchPlatform? @relation(fields: [platformId], references: [id])

  // New platform relations
  primaryPlatformId String?
  primaryPlatform   LaunchPlatform? @relation("PrimaryPlatformOnLaunch", fields: [primaryPlatformId], references: [id])

  listingPlatformId String?
  listingPlatform   LaunchPlatform? @relation("ListingPlatformOnLaunch", fields: [listingPlatformId], references: [id])

  // Lead investor relation
  leadInvestorId String?
  leadInvestor   LeadInvestor? @relation(fields: [leadInvestorId], references: [id])

  salePriceUsd  Float?
  tokensForSale Float?
  totalRaiseUsd Float?

  airdropPercent  Float?
  airdropValueUsd Float?

  vestingInfo Json?

  // price tracking: store one primary smart contract address per chain
  tokenAddress String?
  priceSource  String? // e.g. "DEXSCREENER", "OKX", "BINANCE"

  createdById String?
  createdBy   PortalUserProfile? @relation(fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  priceSnapshots DexSnapshot[]

  @@index([platformId])
  @@index([primaryPlatformId])
  @@index([listingPlatformId])
  @@index([leadInvestorId])
  @@index([status])
  @@index([createdById])
}

model LeadInvestor {
  id         String   @id @default(cuid())
  name       String
  slug       String   @unique
  websiteUrl String?
  tier       String? // e.g. "Tier 1", "Tier 2"
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  createdById String?
  createdBy   PortalUserProfile? @relation(fields: [createdById], references: [id])

  launches NewLaunch[]

  @@index([createdById])
}

model DexSnapshot {
  id       String    @id @default(cuid())
  launchId String
  launch   NewLaunch @relation(fields: [launchId], references: [id], onDelete: Cascade)

  priceUsd  Float
  volume24h Float?
  liquidity Float?
  source    String
  fetchedAt DateTime @default(now())

  @@index([launchId])
  @@index([fetchedAt])
}

model WhaleEntry {
  id           String   @id @default(cuid())
  tokenSymbol  String
  tokenAddress String
  chain        String // e.g. 'ethereum', 'solana', 'base'
  wallet       String // whale wallet address
  amountUsd    Float
  txHash       String   @unique
  occurredAt   DateTime
  createdAt    DateTime @default(now())

  @@index([tokenSymbol, occurredAt])
  @@index([chain, occurredAt])
}

model StablecoinFlowSnapshot {
  id           String   @id @default(cuid())
  stableSymbol String // 'USDT' | 'USDC'
  fromChain    String // e.g. 'ethereum', 'solana', 'base'
  toChain      String // e.g. 'solana', 'base', 'ethereum'
  netAmountUsd Float // positive for net inflow TO toChain FROM fromChain
  windowStart  DateTime
  windowEnd    DateTime
  createdAt    DateTime @default(now())

  @@index([stableSymbol, fromChain, toChain, windowEnd])
}

model LiquiditySignal {
  id           String   @id @default(cuid())
  type         String // 'SOL_MEME_SEASON' | 'BASE_SOCIALFI' | 'ETH_RISK_OFF' | 'GENERIC_FLOW' | 'TOKEN_WHALE_ACCUMULATION'
  title        String // short title
  description  String // human readable text
  severity     Int // 1-3
  chain        String? // primary chain this relates to
  stableSymbol String? // if stablecoin-based
  tokenSymbol  String? // for token whale signals
  dataJson     String? // optional JSON payload
  triggeredAt  DateTime
  createdAt    DateTime @default(now())

  @@index([type, triggeredAt])
  @@index([chain, triggeredAt])
}

// ============================================
// MARKET & MEME SNAPSHOTS (Portal Cron Data)
// ============================================

model MarketSnapshot {
  id           String   @id @default(cuid())
  symbol       String
  name         String
  priceUsd     Float
  marketCapUsd Float?
  volume24hUsd Float?
  change24hPct Float?
  source       String // e.g. "coingecko_trending"
  createdAt    DateTime @default(now())

  @@index([createdAt])
  @@index([source])
}

model MemeTokenSnapshot {
  id           String   @id @default(cuid())
  symbol       String
  name         String
  priceUsd     Float
  marketCapUsd Float?
  change24hPct Float?
  source       String // e.g. "coingecko_pumpfun"
  createdAt    DateTime @default(now())

  @@index([createdAt])
  @@index([source])
}

// ============================================
// DEX & CEX ENRICHMENT LAYER (Portal)
// ============================================

model DexMarketSnapshot {
  id           String   @id // text PK, Prisma will set it
  symbol       String?  @db.Text
  name         String?  @db.Text
  source       String   @db.Text
  chain        String?  @db.Text
  dex          String?  @db.Text
  pairAddress  String?  @db.Text
  tokenAddress String?  @db.Text
  priceUsd     Float?   @db.DoublePrecision
  liquidityUsd Float?   @db.DoublePrecision
  volume24hUsd Float?   @db.DoublePrecision
  txns24h      Int?     @db.Integer
  createdAt    DateTime @default(now()) @db.Timestamptz(6)

  @@index([chain])
  @@index([tokenAddress])
  @@index([createdAt])
}

model CexMarketSnapshot {
  id              String   @id // text PK
  symbol          String   @db.Text
  baseAsset       String?  @db.Text
  quoteAsset      String?  @db.Text
  source          String   @db.Text
  priceUsd        Float?   @db.DoublePrecision
  volume24hUsd    Float?   @db.DoublePrecision
  openInterestUsd Float?   @db.DoublePrecision
  createdAt       DateTime @default(now()) @db.Timestamptz(6)

  @@index([symbol])
  @@index([createdAt])
}

// ============================================
// ANALYST SOCIAL BOOST PROMO
// ============================================
// Tracks promo state for the "Analyst Social Boost" quest
// where Seer users can earn 3 days of Analyst access by
// following @MysticHeros and posting a tweet with akarimystic.club

model AnalystSocialBoostPromo {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @unique @map("user_id") @db.Uuid
  status        String    @default("never_seen") // never_seen, accepted, declined_recently, declined_long_term, completed
  timesDeclined Int       @default(0) @map("times_declined")
  lastShownAt   DateTime? @map("last_shown_at") @db.Timestamptz(6)
  nextShowAt    DateTime? @map("next_show_at") @db.Timestamptz(6)
  activatedAt   DateTime? @map("activated_at") @db.Timestamptz(6)
  expiresAt     DateTime? @map("expires_at") @db.Timestamptz(6)
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@map("analyst_social_boost_promo")
  @@index([status])
  @@index([nextShowAt])
}

// ============================================
// PROJECT REFRESH STATE (Smart Refresh System)
// ============================================

// Tracks user interest and refresh scheduling for each project.
// Used by the smart refresh cron to determine which projects need refreshing.
model ProjectRefreshState {
  projectId            String    @id @map("project_id") @db.Uuid
  
  // User interaction timestamps
  lastManualViewAt     DateTime? @map("last_manual_view_at") @db.Timestamptz(6)
  lastSearchedAt       DateTime? @map("last_searched_at") @db.Timestamptz(6)
  lastCronRefreshedAt  DateTime? @map("last_cron_refreshed_at") @db.Timestamptz(6)
  
  // Computed metrics
  inactivityDays       Int       @default(0) @map("inactivity_days")
  interestScore        Int       @default(0) @map("interest_score")
  
  // Refresh scheduling
  refreshFrequency     String    @default("daily") @map("refresh_frequency") // "daily", "3_days", "weekly"
  
  // Timestamps
  createdAt            DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt            DateTime  @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@index([refreshFrequency])
  @@index([interestScore(sort: Desc)])
  @@index([lastCronRefreshedAt])
  @@map("project_refresh_state")
}

// ============================================
// USER CT ACTIVITY (Phase 1 Value System)
// ============================================

// Stores per-tweet activity for each AKARI user + project
// Captures user's engagement with tracked projects through their tweets
model UserCtActivity {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @map("user_id") @db.Uuid
  xUserId       String    @map("x_user_id") @db.Text
  tweetId       String    @map("tweet_id") @db.Text
  tweetUrl      String    @map("tweet_url") @db.Text
  tweetedAt     DateTime  @map("tweeted_at") @db.Timestamptz(6)
  projectId     String    @map("project_id") @db.Uuid
  projectSlug   String    @map("project_slug") @db.Text
  likes         Int       @default(0)
  replies       Int       @default(0)
  retweets      Int       @default(0)
  quoteCount    Int       @default(0) @map("quote_count")
  sentimentScore Int?     @map("sentiment_score") // -100 to 100, optional
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([userId, tweetId, projectId])
  @@index([userId])
  @@index([projectId])
  @@index([tweetedAt])
  @@map("user_ct_activity")
}

// Aggregated value scores for each user→project pair
// Computed periodically from user_ct_activity (based on last 200 tweets)
model UserProjectValueScore {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @map("user_id") @db.Uuid
  projectId       String    @map("project_id") @db.Uuid
  projectSlug     String    @map("project_slug") @db.Text
  sourceWindow    String    @default("last_200_tweets") @map("source_window") @db.Text // e.g. 'last_200_tweets'
  tweetCount      Int       @default(0) @map("tweet_count")
  totalLikes      Int       @default(0) @map("total_likes")
  totalReplies    Int       @default(0) @map("total_replies")
  totalRetweets   Int       @default(0) @map("total_retweets")
  totalEngagement Int       @default(0) @map("total_engagement")
  valueScore      Int       @default(0) @map("value_score")
  lastTweetedAt   DateTime? @map("last_tweeted_at") @db.Timestamptz(6)
  computedAt      DateTime  @default(now()) @map("computed_at") @db.Timestamptz(6)

  @@unique([userId, projectId, sourceWindow])
  @@index([userId])
  @@index([valueScore(sort: Desc)])
  @@map("user_project_value_scores")
}
